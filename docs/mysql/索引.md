# 目录

* [索引](#索引)
      * [通过本篇文章能知道：](#通过本篇文章能知道)
      * [数据结构](#数据结构)
         * [哈希索引](#哈希索引)
         * [B Tree](#btree)
         * [B Tree](#btree-1)
      * [聚集索引和非聚集索引](#聚集索引和非聚集索引)
         * [概念：](#概念)
         * [回表](#回表)
      * [复合索引](#复合索引)
      * [如何分析SQL语句执行情况？](#如何分析sql语句执行情况)
      * [最左匹配原则](#最左匹配原则)
      * [覆盖索引](#覆盖索引)
      * [杂谈](#杂谈)
         * [针对什么样的列建立索引？](#针对什么样的列建立索引)
         * [索引越多越好吗？](#索引越多越好吗)
         * [少用select *](#少用select-)
         * [索引失效的几种原因](#索引失效的几种原因)


# 索引

## 通过本篇文章能知道：

1. 索引的基础数据结构和原理
2. 分析索引失效的方法
3. 建立索引的技巧和实际开发当中对索引的优化

## 数据结构

### 哈希索引

> **概述：** InnoDB默认使用的是B+Tree索引，哈希索引在官方文档中表示无法主动创建，只能是由InnoDB引擎自动优化创建。
>
> 哈希索引就是采用哈希算法，将主键或者索引的值换算成哈希值，哈希算法不需要像树结构的逐级查找，只需要一次哈希算法就可以立即定位。 ![在这里插入图片描述](https://github.com/Coder999z/Java-Notes/blob/master/img/1/0009.png)
>
> - 与B+ 树对比，如果是通过索引的等值查询，哈希索引有明显的优势。但是如果有大量的重复的键，出现了哈希碰撞比较严重，那么就需要遍历链表，大数据下也是影响性能的。
> - 哈希索引不支持范围查询。因为有序的键在哈希算法后可能就不再连续了，只能够逐个哈希查询。
> - **总结：** 总的来说哈希索引的稳定性不如B+Tree，出现了大量哈希碰撞后哈希索引的效率也是极低的。

### B+Tree

> **概念：** B+Tree中的B是balance，指的是平衡，它叫平衡多路查找树。它是为`磁盘`等外设设备设计的一种`平衡查找树`，磁盘的I/O速度一直是数据库的瓶颈所在，针对一次增删改查，越少的磁盘I/O就越有利于性能。
>
> **为何选用B+Tree？**
>
> 先看一下二叉查找树（左子树的键值小于根的键值，右子树的键值大于根的键值），二叉查找树可以任意的构造，可以是这样：![img](https://github.com/Coder999z/Java-Notes/blob/master/img/1/71.png)
>
> 也可以是这样：
>
> ![img](https://github.com/Coder999z/Java-Notes/blob/master/img/1/70.png)
>
> 显然后者的二叉树搜索效率并不高，严重时甚至退化成线性查找。我们希望二叉树能够排列均匀，就有了平衡二叉树（AVL树 在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1）
>
> ![img](https://github.com/Coder999z/Java-Notes/blob/master/img/1/73.png)
>
> 为了适应磁盘的读取方式提高搜索方式，依照平衡二叉树出现了B-Tree，而B+Tree是对B-Tree的优化。
>
> > **磁盘的读取方式：**系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的（默认4KB），位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
> >
> > **InnoDB中的页：** InnoDB中默认每个页的大小为16kb，可以通过设置参数innodb_page_size来将页的大小设置为4k、8k、16k，即为磁盘块大小的整数倍，便于读取。
>
> **B-Tree**
>
> ![img](https://github.com/Coder999z/Java-Notes/blob/master/img/1/74.png)
>
> - 图中，磁盘块1，磁盘2.....表示的是`InnoDB中的“页”`，在磁盘中的表现形式为连续地址的磁盘页（例如InnoDB中设置页大小为8kb，那么在磁盘中就是两个连续地址的磁盘页，确保一次IO就可以读取到一个节点的数据）
> - 在B-Tree中，每个非叶子节点磁盘块中存放有：
>
> > **指针：** 存储子节点的磁盘地址。
> >
> > **键值：** 主键的值
> >
> > **数据：** 表记录中的数据
>
> > 模拟查找主键=75的记录的过程：
>
> > 1. 读取根节点，载入内存。 **【第一次磁盘IO】**
> > 2. 依据搜索算法判断75在p3指针指向的磁盘块，获得指向磁盘块4的指针。
> > 3. 读取磁盘块4，载入内存。 **【第二次磁盘IO】**
> > 4. 同理，获得指向磁盘块10的指针。
> > 5. 读取磁盘块10，载入内存。 **【第三次磁盘IO】**
> > 6. 找到主键=75的记录。
>
> > B-Tree中的键值对存储了主键和对应的行记录，那么如果行记录中的数据较大，每个磁盘块中能够存储的主键范围就越小，导致整颗B-Tree的深度变大，那么磁盘的IO次数也就会增多，导致性能的下降。
> > </br>
> > 假设每个非叶子节点能存3个键值对时的结构：
> >
> > ![在这里插入图片描述](https://github.com/Coder999z/Java-Notes/blob/master/img/1/0006.png)当每行记录的数据变大时，假设只能存2两个键值对了，那么可能会多出一层到两层，也就多了一次或两次IO操作。
> > ![在这里插入图片描述](https://github.com/Coder999z/Java-Notes/blob/master/img/1/0007.png)
> >
> > 原先第一层可以放下四个指针，对应第二层就会有四个页，当数据占用空间变大后，第一层最后只能存放三个指针，那么第二层对应也只能有三个页。同理因为数据所占空间变大了，底层每个叶子节点能存放的数据范围也变小了，那么就需要上层有更多的指针指向变多的叶子节点，那么B-Tree的深度就增加了，这将导致数据库性能不稳定。
>
> ### B+Tree
>
> > B+Tree正是对B-Tree中存在的问题的优化。
> >
> > ![在这里插入图片描述](https://github.com/Coder999z/Java-Notes/blob/master/img/1/0008.png)
> >
> > - **结构：** 对比B-Tree可以发现，在B+数的非叶节点中不再存储数据，所有的数据都存储在叶子节点中。并且最底层的叶子节点是一个双向链表。
> > - **优点：** 非叶子节点只存储指针和主键值以后，每个磁盘块中能够存放的主键数大大增加，那么整颗树会变“胖”，降低了深度，减少IO次数从而提高性能。
> > - **推算：**
> >
> > > InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

## 聚集索引和非聚集索引

### 概念：

> - **聚集索引：**  指的是主索引文件和数据文件为同一份文件（primary key所在的B+Tree）。
>
> - **非聚集索引：** 指的是B+树的叶子节点上存储的数据并不是行记录中的数据，而是存放主键（key，unique key）。
>

### 回表

> 从非聚集索引树上获得主键之后到主键索引树查询数据的过程叫做回表。

> 举个例子：
>
> ```sql
> CREATE TABLE `t1` (
> `employee_id` int(11) NOT NULL AUTO_INCREMENT,
> `human_id` varchar(30) ,
> PRIMARY KEY (`employee_id`),
> UNIQUE KEY `index` (`human_id`) USING BTREE
> );
> 
> select * from t1 where human_id='123456';
> ```
>
> 1. 根据human_id='123456'，在其索引树上找到对应的记录后获得主键
> 2. 根据查找到的主键到主键的索引文件中寻找对应的记录。
>    这个过程就是`回表`

## 复合索引

> **概念：**复合索引又叫联合索引，由两个或两个以上的列组成的索引称为联合索引。
>
> 先看一个例子：
>
> ```sql
> CREATE TABLE `t1` (
>   `id` int(11) NOT NULL AUTO_INCREMENT,
>   `a` int(255) ,
>   `b` int(255) ,
>   `c` int(255) ,
>   `d` int(255) ,
>   PRIMARY KEY (`id`),
>   KEY `index` (`a`)
> ) 
> ```
>
> 表内假设有500W条数据，a = 1的有100W条，此时执行
>
> ```sql
> select * from t1 where a = 1 and b = 2 and c = 3;
> ```
>
> 此时查询的步骤为：
>
> > 1. 从索引a的B+树中获得a = 1的所有记录的主键，共100W条
> > 2. 根据这100W条主键回表查询出对应的记录，再筛选出b = 2，c = 3的记录。看起来效率并不乐观
> >
> > ![](https://github.com/Coder999z/Java-Notes/blob/master/img/1/QQ20191209-154841.png)
>
> 若针对表中a、b、c三个列创建了联合主键后查询的步骤为：
>
> > 1. 从符合索引(a,b,c)的B+树中获得条件的所有记录的主键
> > 2. 回表查询数据
> >
> > ![](https://github.com/Coder999z/Java-Notes/blob/master/img/1/QQ20191209-155020.png)
>
> **复合索引适合在由多个列来确定一行或者多行数据时使用**
>
> > 例如确定一个游戏的角色，需要从游戏账号-->游戏大区-->角色名，多个条件确定。
>
> **数据结构：**
>
> ```sql
> CREATE TABLE `t2` (
> `id` int(11) NOT NULL AUTO_INCREMENT,
> `a` int(255) ,
> `b` int(255) ,
> `c` int(255) ,
> `d` int(255) ,
> PRIMARY KEY (`id`),
> KEY `index` (`a`,`b`,`c`) USING BTREE
> ) 
> ```
>
> ![image-20191205153457874](https://github.com/Coder999z/Java-Notes/blob/master/img/1/QQ20191205-164932.png)
>
> (a,b,c)复合索引的B+树结构和其他索引完全相同，整棵树依据a列组织，只有在叶子节点中存储的数据有所不同，可以发现`B+树是由列a组织起来的，叶子节点的数据是按照(a,b,c)三个索引的顺序进行排序的`。

## 如何分析SQL语句执行情况？

> 推荐使用explain命令查看SQL语句的执行计划
>
> ```sql
> -- 用法示例
> explain select * from t1 where a = 1;
> ```
>
> 具体的使用方式推荐阅读：https://www.cnblogs.com/tufujie/p/9413852.html
>
> ![image-20191205153457874](https://github.com/Coder999z/Java-Notes/blob/master/img/1/QQ20191210-195534.png)
>
> 篇幅所限本篇文章只列出type字段的含义：
>
> | 字段名 | 值    | 含义                                                     |
> | ------ | ----- | -------------------------------------------------------- |
> | type   | ALL   | 全表扫描                                                 |
> |        | index | 扫描整颗索引树                                           |
> |        | range | 扫描部分索引，索引的范围扫描                             |
> |        | ref   | 使用非唯一索引或非唯一索引的前缀进行的查找               |
> |        | const | 精确查找，单表中只有一个匹配行，例如主键和唯一索引的查询 |

## 最左匹配原则

> 最左匹配原则只在复合索引当中适用，也是最容易出现失效的地方。

> 例子：
>
> ```sql
> CREATE TABLE `t2` (
> `id` int(11) NOT NULL AUTO_INCREMENT,
> `a` int(255) ,
> `b` int(255) ,
> `c` int(255) ,
> `d` int(255) ,
> PRIMARY KEY (`id`),
> KEY `index` (`a`,`b`,`c`) USING BTREE
> ) 
> ```
>
> ![image-20191205153457874](https://github.com/Coder999z/Java-Notes/blob/master/img/1/QQ20191205-164932.png)
>
> **情况一：**
>
> ```sql
> 1. select * from t2 where a = 1;
> 2. select * from t2 where a = 1 and b = 2;
> 3. select * from t2 where a = 1 and b = 2 and c = 4;
> ```
>
> 1. 按照条件a找到非聚集索引树中所有对应的主键回表查询。
> 2. 按照条件a在索引树中找到对应记录，再在这些记录中筛选条件b，找到所有对应的主键回表查询。
> 3. 同理
>
> **情况二：**
>
> ```sql
> select * from t2 where a = 1 and c = 4;
> ```
>
> 按照条件a在索引树中找到对应记录，接着将索引树上所有a = 1的记录遍历获得c = 4的记录对应的主键，回表。这条语句中索引命中了a，无法命中c
>
> 这里条件 c = 4没有使用到随机访问是因为，在确定a的值时只能保证b列是有序的（B+树的随机访问使用的是类似二分查找法的搜索算法，都是建立在有序的基础上的），c列无序，所以只能遍历。
>
> **情况三：**
>
> ```sql
> 1. select * from t2 where b = 2;
> 2. select * from t2 where b = 2 and c = 3;
> ```
>
> 这两条SQL都会进行全表扫描，因为B+索引树只能由一个列来组织，复合索引中使用的是第一个列，因此条件只有b 和 c，那么SQL优化器会直接选择全表扫描记录。
>
> **情况四：**
>
> ```sql
> 1. select * from t2 where a = 1 and b > 2;
> 2. select * from t2 where a = 2 and b = 3 and c between 4 and 9;
> 3. select * from t2 where a = 1 and b > 3 and c = 4;
> 4. select * from t2 where a = 2 and c >2;
> ```
>
> 1. 根据a = 1缩小索引树筛选范围后，再根据b > 2范围扫描
> 2. 同理
> 3. 根据a = 1缩小索引树筛选范围后，再根据b > 3范围扫描，再`遍历`范围扫描得出的全部结果筛选c=4，回表。`遇到范围扫描后就会退化为遍历扫描`。
> 4. 根据a = 2缩小索引树筛选范围后，扫描范围内全部记录筛选c > 2的主键回表。还是因为确认a后只能保证b的顺序，c仍然是无序的 只能全部扫描。
>
> **情况五：**
>
> > ```sql
> > 1. select * from t2 where c = 1 and a = 2 and b = 4;
> > 2. select * from t2 where b > 10 and a = 2 ;
> > ```
> >
> > 以上两种打乱了顺序的情况，SQL优化器会自动选择合适的索引列，1.命中三个索引，2.命中一个，假设都能达到预期的执行效率，但是在可读性上较差，建议按照复合索引建立的顺序写where条件。
>
> **总结：**
>
> - 在使用联合索引时必须根据联合索引的顺序来指定条件，否则索引可能失效
> - 联合索引在遇到范围查询（>、<、between and、like右匹配和全模糊）后对后面的条件讲不再使用索引。
> - 以上最根本的原因在于遇到范围查询或者跳过了复合索引中的某个列后，将无法保证下一个列的有序性

## 覆盖索引

> 覆盖索引不是一种索引，它是一种特殊的查询情况：
>
> ```sql
> CREATE TABLE `t2` (
> `id` int(11) NOT NULL AUTO_INCREMENT,
> `a` int(255) ,
> `b` int(255) ,
> `c` int(255) ,
> `d` int(255) ,
> PRIMARY KEY (`id`),
> KEY `index` (`a`,`b`,`c`) USING BTREE
> ) 
> -- 还是同样的表结构
> select c from t2 where a = 1 and b = 1;
> ```
>
> > 还是举个例子，在道具发放时，需要查询是否重复发放，需要从几个亿的大表里查询sn是否已经存在，那么肯定针对sn字段添加了索引，那么仅仅只是查重无需返回其他字段的数据，使用覆盖索引显然效率更高。
>
> ![img](https://github.com/Coder999z/Java-Notes/blob/master/img/1/QQ20191209-155446.png)
>
> 在这条SQL中，查询的b、c列正好是复合索引中的列，那么在where条件正确的按照复合索引树检索时可以直接从复合索引树上拿到b和c的数据，那么就无需回表操作了，这也是提升性能的一种方式。

## 杂谈

### 针对什么样的列建立索引？

> 1. 以区分度高的列建立索引，使用索引的目的在于快速定位缩小搜索的范围，如果使用了包含很多重复值的列，对检索效率的提升就不是很明显了。
>
> 2. 尽量不要使用长度过长的列作为主键（UUID，SN号等等），根据索引的数据结构可知，索引列占用的空间越大，随着数据量的增大，B+树深度也会随之增大，影响效率。

### 索引越多越好吗？

> 每个索引就需要对应一颗B+Tree，添加索引有利于检索数据，但是在增删改数据时除了聚集索引树以外还需要对所有的辅助索引树进行维护，过多的索引会导致修改操作的效率变低。

> 可以在添加索引时考虑一下使用复合索引是否合适。

> ·举个例子：
>
> ```sql
> CREATE TABLE `recharge` (
> `id` int(11) NOT NULL AUTO_INCREMENT,
> `account` int(255) DEFAULT NULL,
> `game_id` int(255) DEFAULT NULL,
> 省略其他字段
> PRIMARY KEY (`id`),
> unique key 'index' ('account')
> ) 
> ```
>
> 在recharge表中需要查询某个账户的具体某个游戏下的充值记录，此时在account上已经有了一个索引，并且game_id在需求中通常只和account_id配合使用，此时就没有必要专门为game_id建立一个索引，可以将index修改为联合索引。

### 少用select * 

> 在很多Java的Dao层框架，例如SpringData JPA，MyBatis Plus等框架当中有封装一些常用的selectAll( )，selectOne( )，selectList( )等等，默认使用的就是select *，在实际业务当中字段通常很多，查询出多余不需要的字段对带宽和后台服务器内存都有一定的浪费。其次是select *几乎不可能命中覆盖索引，因此建议尽量指定查询的列。

### 索引失效的几种原因

> 在最左匹配原则中提到，当遇到范围查询后后序就不再使用索引，在单列所以中，碰到范围查询（>，<，or，like，in）也是会出现全表扫描的情况。因此在范围扫描碰上索引时就要引起注意了，无法确定SQL的执行计划则使用explain命令查看。
>
> 另外还有在查询的列上有运算或者函数也会导致索引失效
>
> ```sql
> select * from t1 where a+1=2;
> ```
>
> 文章无法罗列所有索引失效的情况，弄清楚原理才能够举一反三。
