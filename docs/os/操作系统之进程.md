
* [内存分配](#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D)
  * [题外话](#%E9%A2%98%E5%A4%96%E8%AF%9D)
  * [前言](#%E5%89%8D%E8%A8%80)
  * [内存分配方式](#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F)
    * [连续内存分配](#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D)
    * [非连续内存分配](#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D)
  * [虚拟内存](#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
  * [参考](#%E5%8F%82%E8%80%83)

# 进程

## 什么是进程

> **定义**：计算机中的程序关于某数据集合上的一次运行活动，`进程是系统进行资源分配和调度的基本单位`。

## 进程的特点

> - 动态性：可以动态的创建结束进程
> - 并发性：进程可以被独立调度并占用处理机执行（下文会讲到CPU的调度机制）
> - 独立性：不同进程之间不会互相影响，在介绍内存部分时，页式存储为每个进程都独立创建了页表，不同进程间的内存空间不能直接访问

## 进程状态变化模型

> - **New（创建状态）**一个进程正在被创建还没进入就绪状态之前。
> - **Ready（就绪状态）**一个进程获得了除处理机（CPU）之外的一切资源，一旦获得处理机即可执行的状态。
> - **Running（运行状态）**当一个进程正在被CPU执行时。
> - **Blocked（等待/阻塞状态）**一个进程因为等待某一事件而暂停运行时的状态。如等待资源读取，等待某个事件执行完成。
> - **Exit（结束状态）**一个进程正在从系统中消失时的状态，因为进程结束或者其他原因所导致。
>
> ![1569576947230](https://github.com/Coder999z/Java-Notes/blob/master/img/1/1569576947230.png)

## 状态队列

> 操作系统维护一组队列用来表示进程的当前状态，不同的状态使用不同的队列来表示（就绪队列、不同类型的阻塞队列等）

> 进程的状态变化的实质是将进程对应的PCB放入对应状态的队列中。如从就绪态转为阻塞态，将PCB从就绪队列中脱离，加入到阻塞队列中。

## 进程的生命周期

> - **进程创建：**引起进程创建通常由三个情况触发：系统初始化、用户请求创建、正在运行的进程执行了创建进程的系统调用（创建子进程）
> - **进程运行：**内核选择一个就绪的进程，让他占用CPU执行。
> - **进程等待：**对应的是阻塞状态，触发的情形和阻塞相同
> - **进程唤醒：**进程唤醒的实质是状态变更为就绪态
> - **进程结束：**通常有正常退出、错误退出、致命错误、被其他进程杀死

## PCB

> **Process Control Block**：进程控制块，是操作系统`管理控制进程运行`所用的信息集合。
>
> 操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志。

> **PCB生命周期：** 与进程的生命周期同步，`进程创建时生成PCB`（从New状态进入Ready之间），`进程终止时回收PCB`

> **PCB存储内容：**
>
> > 1. **进程标识信息。**记录本进程标识（id），进程的父进程标识和用户标识等。
>
> > 2. **处理机状态信息保存。**保存进程的运行现场的信息，如用户程序可用的数据，地址寄存器，程序计数器，栈指针等。通常在上下文切换时将现场信息保存在此。
>
> > 3. **进程控制信息。**保存系统用于控制进程的信息，如：
> >    - 调度和状态信息（记录了进程是否正在占用CPU执行，进程的执行状态阻塞还是就绪态）
> >    - 进程间通信信息（保存进程间通信的标识、信号、信件等）
> >    - 存储管理信息（保存进程本身在内存中占用的空间地址等信息，在分配扩展时释放时可以读取）
> >    - 系统所用资源，相关数据结构连接信息等

> **PCB的保存方式：**
>
> > PCB通常以链表的形式保存，因为它的增删频繁，使用数组需要维护索引开销较大。

## 进程挂起

> **什么是进程挂起？** 
>
> 进程挂起和阻塞不同，阻塞的进程仍然在占用内存空间，而进程在挂起状态时，意味着进程没有占用内存空间，而是被持久化到磁盘上了，可以回顾一下内存章节讲到的虚拟内存，当主存容量不足时，可以将不活跃的进程存入磁盘中从而腾出空间给新进程使用，这个过程就是挂起的过程。

> **两种挂起状态：**
>
> > - **阻塞挂起（Blocked-suspend）**进程在磁盘并等待某一事件完成。
> > - **就绪挂起（Ready-suspend）**进程在磁盘，但是只要重回内存即可运行

>**与挂起相关的几种状态转换：**
>
>1. **挂起：** 统一情况为内存不足时为腾出空间给新进程或就绪进程需要更多内存资源时
>
>> - **阻塞->阻塞挂起。** 将阻塞态的进程挂起，腾出空间。
>> - **就绪->就绪挂起。**当有高优先级阻塞进程（操作系统认为横跨就会就绪的）时，系统会选择优先级较低的就绪进程。
>> - **运行->就绪挂起。**在抢占式分时系统中，有高优先级线程需要执行时，系统可能会把某些运行进程转到就绪挂起。
>
>2. **在磁盘中的状态转换：**
>
>> - **阻塞挂起->就绪挂起。**阻塞进程等待的事件完成了，操作系统将阻塞挂起变为就绪挂起。
>
>3. **挂起恢复：**
>
>> - **就绪挂起->就绪。**没有就绪进程或者就绪挂起进程的优先级高于此进程时，就会进程这种转换。
>> - **阻塞挂起->阻塞。**系统内存充足时，系统会将高优先级阻塞挂起进程恢复为阻塞进程。

# 线程

## 为什么需要线程

> 早期的操作系统都是以`进程`为最小的调度单位，但是随着程序复杂度的提升，进程逐渐无法满足程序设计的需要。
>
> 进程在同一时间只能做一件事，例如把播放音乐作为一个任务，那么需要读取音频文件和输出给外置设备播放，如下图所示
>
> ![1569578961633](https://github.com/Coder999z/Java-Notes/blob/master/img/1/1569578961633.png)
>
> 那么问题来了，IO的速度远小于CPU的执行速度，那么可能出现播放不连贯的问题。如果使用多进程的方式呢？
>
> ![1569579038014](https://github.com/Coder999z/Java-Notes/blob/master/img/1/1569579038014.png)
>
> 看似没有问题，但是细想下去，涉及到程序之间的通讯，数据的拷贝，并且系统维护进程需要创建PCB分配资源，撤销进程时又需要撤销PCB，回收资源，程序如果频繁创建进程对操作系统的进程损耗也是非常大的。
>
> **为了解决上述问题，那么就需要提出一个新的实体令它满足：**
>
> 1. 实体之间能并发执行
> 2. 创建和回收更加轻量级
> 3. 实体之间能够共享相同的地址空间（资源）
>
> 于是线程就诞生了！

## 线程与进程

> 明白了线程的由来后就更好理解线程和进程之间的关系了

> **线程**是操作系统能够进行`运算调度`的最小单位
>
> **进程**是系统`分配资源`的最小单位
>
> **线程 = 进程 - 共享资源**
>
> 进程管理了线程所共享的一个资源平台，包括地址空间（程序代码，数据段）、打开的文件等各种资源。而线程是代码在这个资源平台上的一条执行流程。说白了就是进程包含线程，线程是进程中具体实现功能的部分，进程为线程们维护一个共享的资源平台。

### 线程是如何代替多进程的

> 1. 一个进程中可以有多个进程
> 2. 各个线程在进程中资源是共享的，并且线程之间可以并发执行。
> 3. 线程拥有TCB（Thread Control Block）线程控制块，在TCB中存储管理线程相关的信息，如程序计数器、堆栈、寄存器等。线程与线程之间又是相互独立的。
> 4. 线程不需要考虑资源的创建分配和释放，所以线程的创建销毁和上下文切换的开销都要远小于进程
>
> ![1569582714257](https://github.com/Coder999z/Java-Notes/blob/master/img/1/1569582714257.png)

## 上下文切换

> **什么是上下文切换？**
>
> > 指CPU中一个进程或线程切换到另一个进程或线程。(从运行状态切换到其他状态)
>
> > 上下文切换需要保存进程或线程的运行时信息，保存寄存器（程序计数器，堆栈），CPU状态等等
> >
> > 进程和线程的上下文切换是不同的，他们的差别在于除了保存上述内容外进程的上下文切换还需要切换页目录以使用新的地址空间。
> >
> > 因而线程的上下文切换的开销要小于进程的上下文切换。
>
> **什么时候会触发上下文切换？**
>
> > 1. 最常见的便是CPU的时间片机制，在一个进程/线程的时间片用完后操作系统会打断它触发上下文切换，让其他进程/线程执行。
> > 2. 进程/线程在运行时需要等待一个事件的完成，转而进入阻塞态，这个过程也是会触发上下文切换。
> > 3. 只要是从运行状态切换到其他状态（除了退出）都是需要保存上下文信息的，以便恢复时继续执行。
>
> **CPU的最小调度单位是线程，那进程又是如何切换的呢？**
>
> > 这个问题一直困扰我很久，对Linux内核来说，对线程和进程的操作其实是没有什么区别的，唯一的区别在于进程的上下文切换比线程多一步：切换页目录以使用新的地址空间。

## CPU调度

> **批处理操作系统：**早期的操作系统，常用于计算量大、不需要交互的大型作业，操作员一次性将所有的程序输入到计算机系统，并在运行时无法进行 干预直到结束。
>
> **分时操作系统：**计算机能被多个用户同时使用，系统能以最快速度将结果反馈给用户，并且用户和计算机的交互性更好。
>
> **实时操作系统：**当外界事件或数据产生时，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点。

> **非抢占式调度：**让进程运行直到其主动放弃CPU执行权或直到结束或阻塞的调度方式，适合专用系统。
>
> **抢占式调度：**优先让优先级高的进程/线程使用CPU，如果优先级相同则随机选择一个。

> **几种常见的CPU调度算法：**
>
> **批处理系统中的调度算法：**
>
> > 1. **FCFS先来先服务：**按照进程/线程到来的顺序执行。缺点是如果大任务排在前可能造成平均周转时间较长。
> > 2. **SJF最短作业优先：**领执行时间较短的先执行。缺点是可能造成大任务长期处于饥饿状态。
> > 3. **最高响应比优先：**调度时会计算每一个进程/线程的响应比，防止某个进程/线程等待时间过长。响应比R  =   1+（等待时间/处理时间）
>
> **分时操作系统中的调度算法：**
>
> > 1. **RR-时间片轮转法：**将就绪进程/线程放入就绪队列中，并给定每个运行态的进程/线程指定的运行时间，称之为时间片，当其时间片用完后，计时器会发出中断请求，操作系统会使正在运行的进程/线程保存上下文信息，并由调度器选择下一个执行的进程/线程，为其分配时间片。

